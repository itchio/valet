extern crate neon_build;
use std::{
    env,
    error::Error,
    fs,
    path::{Path, PathBuf},
    process::Command,
};

fn main() {
    neon_build::setup();
    build_libbutler().unwrap();
}

trait CopyTo {
    fn copy_to<D: AsRef<Path>>(&self, dest: D);
}

impl<T> CopyTo for T
where
    T: AsRef<Path>,
{
    fn copy_to<D: AsRef<Path>>(&self, dest: D) {
        let src = self.as_ref();
        let parent = src.parent().unwrap();
        fs::create_dir_all(parent).unwrap();
        fs::copy(src, dest).unwrap();
    }
}

trait RunAndCheck {
    fn run_and_check(&mut self);
}

impl RunAndCheck for Command {
    fn run_and_check(&mut self) {
        let output = self.output().unwrap();
        if !output.status.success() {
            panic!(
                "Command returned non-zero exit code {:?}:\n {}",
                output.status,
                std::str::from_utf8(&output.stderr).unwrap()
            );
        }
    }
}

fn build_libbutler() -> Result<(), Box<dyn Error>> {
    let runtime_dir = env::current_dir().unwrap();
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    let link_dir = out_dir.join("libbutler-prefix");
    fs::create_dir_all(&link_dir)?;

    println!("cargo:rustc-link-lib={}", "butler");
    println!("cargo:rustc-link-search={}", link_dir.display());

    let mut go_build_args: Vec<String> =
        vec!["build".into(), "-v".into(), "-buildmode=c-shared".into()];
    let go_pkg = "../libbutler".to_string();

    cfg_if::cfg_if! {
        if #[cfg(target_os = "macos")] {
            let lib_name = "libbutler.dylib";
            let build_lib_path = link_search_dir.join(lib_name);
            let runtime_lib_path = runtime_dir.join(lib_name);
            go_build_args.push(format!("-o={}", build_lib_path.display()));
            go_build_args.push(go_pkg);
            Command::new("go").args(&go_build_args).run_and_check();

            // macOS folklore: need a post-linker tool to adjust the "load
            // directives" so it's relative to `index.node`'s path
            Command::new("install_name_tool").args(&[
                "-id",
                "@loader_path/libbutler.dylib",
                build_lib_path,
            ]).run_and_check();

            build_lib_path.copy_to(runtime_lib_path);
        } else if #[cfg(target_os = "linux")] {
            let lib_name = "libbutler.so";
            let build_lib_path = link_dir.join(lib_name);
            let runtime_lib_path = runtime_dir.join(lib_name);

            go_build_args.push(format!("-o={}", build_lib_path.display()));
            go_build_args.push(go_pkg);
            Command::new("go").args(&go_build_args).run_and_check();

            // Linux folklore: just pass a linker argument so the executable
            // has its own directory in its "library search path"
            println!("cargo:rustc-cdylib-link-arg=-Wl,-rpath=$ORIGIN");

            build_lib_path.copy_to(runtime_lib_path);
        } else if #[cfg(target_os = "windows")] {
            let runtime_lib_name = "butler.dll";
            let runtime_lib_path = runtime_dir.join(runtime_lib_name);
            let build_lib_path = link_dir.join(runtime_lib_name);

            let import_lib_name = "butler.lib";
            let import_lib_path = link_dir.join(import_lib_name);
            let def_gen_path = link_dir.join("butler.def.gen");
            let def_path = link_dir.join("butler.def");

            // Pieces of the puzzle: Go uses gcc, generates a `.dll`. To link
            // against a `.dll`, one needs.. an import library, ie. a `.lib` To
            // make an import library, one needs to call the `lib.exe` utility
            // from MSVC with a `.def` file. Such a file can be generated by
            // mingw-ld with `--output-def`. It's easy really!

            go_build_args.push(format!("-o={}", build_lib_path.display()));
            go_build_args.push("-ldflags".into());
            go_build_args.push(format!("-extldflags -Wl,--output-def,{}", def_gen_path.display()));
            go_build_args.push(go_pkg);
            Command::new("go").args(&go_build_args).run_and_check();

            // Now, Go being Go, it has funky symbol names - some of which `lib.exe`
            // will reject. So we just filter those out from the generated `.def` file
            {
                use std::{io::{BufRead, BufReader, Write, BufWriter}, fs::File};
                let input = BufReader::new(File::open(&def_gen_path)?);
                let mut output = BufWriter::new(File::create(&def_path)?);
                let forbidden_chars = ['{', ';'];
                for line in input.lines() {
                    let line = line?;
                    if forbidden_chars.iter().any(|&c| line.contains(c)) {
                        continue;
                    }
                    writeln!(output, "{}", line)?;
                }
            }

            // Now we just have to generate the `.lib` from the `.def`
            let lib_exe_path = find_lib_exe().expect("need an install of MSVC with lib.exe in it");
            Command::new(lib_exe_path).args(&[
                format!("/def:{}", def_path.display()),
                format!("/out:{}", import_lib_path.display()),
                // TODO: 32-bit support
                "/machine:x64".into(),
            ]).run_and_check();

            build_lib_path.copy_to(runtime_lib_path);
        } else {
            panic!("Only macOS, Linux and Windows are supported");
        }
    }

    Ok(())
}

#[cfg(target_os = "windows")]
fn find_lib_exe() -> Option<PathBuf> {
    use std::io;

    let pf86 = match std::env::var("ProgramFiles(x86)") {
        Ok(res) => PathBuf::from(res),
        Err(_) => {
            println!("cargo:warning=No value for ProgramFiles(x86)");
            return None;
        }
    };

    let vswhere = pf86
        .join("Microsoft Visual Studio")
        .join("Installer")
        .join("vswhere.exe");

    let mut cmd = std::process::Command::new(vswhere);
    cmd.arg("-latest");
    let out = match cmd.output() {
        Ok(res) => res,
        Err(e) => {
            println!("cargo:warning=While running vswhere: {:?}", e);
            return None;
        }
    };

    let s = match std::str::from_utf8(&out.stdout[..]) {
        Ok(x) => x,
        Err(e) => {
            println!("cargo:warning=vswhere gave non-utf8 output: {:?}", e);
            return None;
        }
    };

    let prefix = "installationPath: ";
    for line in s.lines() {
        if line.starts_with(prefix) {
            let value = line.replace(prefix, "");
            let install_path = PathBuf::from(value);

            let tools_path = install_path.join("VC").join("Tools").join("MSVC");
            let f = || -> Result<_, io::Error> {
                let versions = std::fs::read_dir(&tools_path)?
                    .map(|r| r.map(|r| r.file_name()))
                    .collect::<Result<Vec<_>, _>>()?;
                for v in versions {
                    // TODO: 32-bit support
                    let lib_exe_path = tools_path
                        .join(&v)
                        .join("bin")
                        .join("Hostx64")
                        .join("x64")
                        .join("lib.exe");
                    if lib_exe_path.exists() {
                        return Ok(Some(lib_exe_path));
                    } else {
                        println!(
                            "cargo:warning=really thought we'd find lib.exe at: {}",
                            lib_exe_path.display()
                        );
                    }
                }
                Ok(None)
            };

            match f() {
                Ok(x) => {
                    if let Some(x) = x {
                        return Some(x);
                    }
                }
                Err(e) => println!("cargo:warning=While looking for MSVC path: {:?}", e),
            }
        }
    }

    None
}
